ARG AKMODS_REGISTRY_ACTOR=""
ARG AKMODS_REGISTRY_TOKEN=""

RUN bash -euxo pipefail <<'EOF_INNER'
# Detect Fedora major from build root so we select the matching akmods tag.
FEDORA_VERSION="$(rpm -E %fedora)"
AKMODS_IMAGE="ghcr.io/danathar/akmods-zfs:main-${FEDORA_VERSION}"

# Capture kernel release(s) already present in the base image before adding kmods.
# We validate against this exact list after install to avoid publishing stale/mismatched kmods.
mapfile -t image_kernels < <(find /lib/modules -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort)
if [[ "${#image_kernels[@]}" -eq 0 ]]; then
  echo "No kernel directories found in /lib/modules" >&2
  exit 1
fi

# Pull akmods cache image as a local `dir:` layout for direct layer extraction.
# Branch-specific akmods repos can be private, so use credentials when provided.
if [[ -n "${AKMODS_REGISTRY_ACTOR}" && -n "${AKMODS_REGISTRY_TOKEN}" ]]; then
  skopeo copy \
    --retry-times 3 \
    --src-creds "${AKMODS_REGISTRY_ACTOR}:${AKMODS_REGISTRY_TOKEN}" \
    "docker://${AKMODS_IMAGE}" \
    dir:/tmp/akmods-zfs
else
  skopeo copy --retry-times 3 "docker://${AKMODS_IMAGE}" dir:/tmp/akmods-zfs
fi

# Read only manifest layers (not config blobs) and map digest -> local file path.
mapfile -t layer_files < <(
  jq -r '.layers[]?.digest // empty' /tmp/akmods-zfs/manifest.json \
    | sed -E 's#^sha256:#/tmp/akmods-zfs/#'
)
if [[ "${#layer_files[@]}" -eq 0 ]]; then
  echo "No layers found in ${AKMODS_IMAGE}" >&2
  exit 1
fi

# Unpack every image layer so `/tmp/rpms/kmods/zfs` becomes available.
for layer in "${layer_files[@]}"; do
  # Safety check: stop if a tar entry tries absolute or parent-directory paths.
  # That is a fail-closed guard against path traversal in unexpected layer content.
  if tar -tf "${layer}" | grep -Eq '(^/|(^|/)\.\.(/|$))'; then
    echo "Unsafe tar path found in layer ${layer}; refusing extraction." >&2
    exit 1
  fi
  tar -xf "${layer}" -C /tmp/
done

# Select only installable ZFS-related binary RPMs.
mapfile -t zfs_rpms < <(
  find /tmp/rpms/kmods/zfs -maxdepth 1 -type f -name '*.rpm' \
    ! -name '*.src.rpm' \
    ! -name '*-debug*' \
    ! -name '*-devel*' \
    ! -name '*-test*' \
    | sort
)

if [[ "${#zfs_rpms[@]}" -eq 0 ]]; then
  echo "No ZFS RPMs found in ${AKMODS_IMAGE}" >&2
  exit 1
fi

# Install directly into ostree build root.
rpm-ostree install "${zfs_rpms[@]}"

# Fail closed if the cached kmods do not match the kernel(s) from the base image.
# This prevents publishing an image where `kmod-zfs` is installed but `modprobe zfs` fails.
# "Stale" here means the cached module was built for an older kernel release.
for kernel_release in "${image_kernels[@]}"; do
  module_path="/lib/modules/${kernel_release}/extra/zfs/zfs.ko"
  if [[ ! -f "${module_path}" ]]; then
    echo "No ZFS module for base kernel ${kernel_release}. Cached akmods are stale; rebuild akmods." >&2
    exit 1
  fi

  # kmod-zfs postinstall script runs depmod only when uname -r matches target.
  # During image builds uname is usually the builder kernel, so run depmod manually.
  depmod -a "${kernel_release}"
done
EOF_INNER
